

import numpy as np
import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans
from sklearn.linear_model import LogisticRegression
from itertools import combinations
from networkx.algorithms.community import greedy_modularity_communities





# 1. LOAD REAL AML DATA (FROM EXCEL)


FILE_PATH = r"D:\AML project\TCGA_LAML_simulated_3000_patients_binary_mutation_matrix.xlsx"

aml_df = pd.read_excel(FILE_PATH)

GENES = [
    'NPM1','FLT3_ITD','DNMT3A','RUNX1','ASXL1',
    'TP53','IDH1','IDH2','SRSF2','U2AF1',
    'CEBPA_biallelic','Complex_Karyotype'
]

print("[✓] AML dataset loaded from Excel")
print(aml_df.head())





##   Co-occurrence -----Count how often mutations appear together

#Dots (nodes) = genes / mutations

#Lines (edges) = two mutations appear together in many patients

#Thicker/stronger line = they appear together in many patients

# Only draw a line if more than 80 patients have both mutations.


   #  Small numbers may be random-----by select 80 occurence will miss rare or small co occorrence less than 80.

   #  Big numbers are more biologically meaningful



co_occurrence = aml_df[GENES].T.dot(aml_df[GENES])

G = nx.Graph()
G.add_nodes_from(GENES)

for i in range(len(GENES)):
    for j in range(i+1, len(GENES)):
        if co_occurrence.iloc[i, j] > 80:
            G.add_edge(GENES[i], GENES[j],
                       weight=co_occurrence.iloc[i, j])






#Can we automatically find groups of mutations that tend to appear together in the same patients

import networkx as nx
import community as community_louvain  # from python-louvain


# Run Louvain on the weighted graph
partition = community_louvain.best_partition(G, weight='weight')

# partition is a dict: {node: module_id}
print("Louvain communities:")
for node, module in partition.items():
    print(f"{node}: Module {module}")

from collections import defaultdict

modules = defaultdict(list)
for gene, mod in partition.items():
    modules[mod].append(gene)

print("\nModules (Louvain):")
for mod, genes in modules.items():
    print(f"Module {mod}: {genes}")
    
    
# Show the raw co-occurrence numbers 

print("\n")
print("Co-occurrence matrix (number of patients where both mutations appear):")
print(co_occurrence)








import matplotlib.pyplot as plt
import networkx as nx
import matplotlib.patches as mpatches

# Colors for each Louvain module
module_colors = {
    0: "skyblue",
    1: "lightgreen",
    2: "salmon",
    3: "violet"
}

# Node colors based on module assignment
node_colors = [module_colors[partition[g]] for g in G.nodes()]

# Label colors also match module colors
label_colors = {g: module_colors[partition[g]] for g in G.nodes()}

# Edge widths scaled
edges = G.edges()
edge_weights = [G[u][v]['weight'] for u, v in edges]
scaled_widths = [w / 20 for w in edge_weights]

# Layout
pos = nx.spring_layout(G, seed=42, k=2.5, iterations=100)

plt.figure(figsize=(26, 22))

# Draw nodes
nx.draw_networkx_nodes(
    G, pos,
    node_color=node_colors,
    node_size=5500,
    edgecolors='black',
    linewidths=2.5
)

# Draw labels with module‑matching colors
nx.draw_networkx_labels(
    G, pos,
    font_size=18,
    font_weight='bold',
    font_color='black'
)

# Draw edges
nx.draw_networkx_edges(
    G, pos,
    width=scaled_widths,
    alpha=0.9,
    edge_color='black',
    arrows=True,
    arrowsize=15,
    arrowstyle='-|> ',
    connectionstyle="arc3,rad=0.1"
)

# Legend for modules
legend_patches = [
    mpatches.Patch(color='skyblue', label='Module 0'),
    mpatches.Patch(color='lightgreen', label='Module 1'),
    mpatches.Patch(color='salmon', label='Module 2'),
    mpatches.Patch(color='violet', label='Module 3')
]

plt.legend(
    handles=legend_patches,
    fontsize=16,
    loc='upper left',
    bbox_to_anchor=(0, 1),
    frameon=True,
    fancybox=True,
    shadow=True
)

plt.title("AML Mutation Co-occurrence Network and Communities\n",
          fontsize=22, pad=40)

plt.axis('off')
plt.tight_layout()
plt.show()
